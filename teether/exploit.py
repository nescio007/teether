import itertools
import logging
from collections import defaultdict

from z3 import z3

from teether.cfg import opcodes
from teether.constraints import check_model_and_resolve, model_to_calls
from teether.evm.exceptions import IntractablePath
from teether.evm.results import CombinedSymbolicResult
from teether.util.z3_extra_util import concrete


class InfeasibleExploit(Exception):
    pass


class ExploitContext(object):
    def __init__(self, target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                 controlled_addrs=set()):
        self.target_addr = target_addr
        self.shellcode_addr = shellcode_addr
        self.target_amount = target_amount
        self.amount_check = amount_check
        self.initial_balance = initial_balance
        self.initial_storage = initial_storage

        # assume we control the target and shellcode addresses
        self.controlled_addrs = controlled_addrs | {target_addr, shellcode_addr}


def exploit_constraints_call(r, ctx):
    addr = r.state.stack[-2]
    if not concrete(addr):
        addr = z3.simplify(addr)

    amount = r.state.stack[-3]
    if not concrete(amount):
        amount = z3.simplify(amount)

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    if not concrete(amount):
        if ctx.amount_check == '+':
            extra_constraints.append(z3.UGE(amount, ctx.target_amount))
        elif ctx.amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, ctx.target_amount))
        else:
            extra_constraints.append(amount == ctx.target_amount)
        final_balance = r.state.balance
        extra_constraints.append(z3.ULE(amount, final_balance))

    # ensure we're not spending more for this exploit than we gain
    total_spent = None
    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
        if total_spent is None:
            total_spent = callvalue
        else:
            total_spent += callvalue

    extra_constraints.append(z3.ULT(total_spent, amount))

    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    if not ctx.initial_balance:
        start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
        extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    return extra_constraints


def exploit_constraints_callcode(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_delegatecall(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_selfdestruct(r, ctx):
    addr = z3.simplify(r.state.stack[-1])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    return extra_constraints


EXPLOIT_CONSTRAINTS = {
    'CALL': exploit_constraints_call,
    'CALLCODE': exploit_constraints_callcode,
    'DELEGATECALL': exploit_constraints_callcode,
    'SELFDESTRUCT': exploit_constraints_selfdestruct
}


def get_exploit_constraints(r, ctx):
    target_op = r.results[-1].target_op
    if target_op in EXPLOIT_CONSTRAINTS:
        return EXPLOIT_CONSTRAINTS[target_op](r, ctx)
    else:
        return []


def attempt_exploit(results, ctx):
    c = CombinedSymbolicResult()
    for r in results[::-1]:
        c.prepend(r)
    c.combine(ctx.initial_storage, ctx.initial_balance)
    c.simplify()

    extra_constraints = get_exploit_constraints(c, ctx)

    for res in c.results:
        expr = None
        for controlled_addr in ctx.controlled_addrs:
            new_caller = z3.Extract(159, 0, z3.BitVec('CALLER_%d' % res.xid, 256)) == controlled_addr
            if expr is None:
                expr = new_caller
            else:
                expr = z3.Or(expr, new_caller)
        extra_constraints.append(expr)

    try:
        model = check_model_and_resolve(c.constraints + extra_constraints, c.sha_constraints)

        # enforce we control all CALLER-addresses
        if any(model[v].as_long() not in ctx.controlled_addrs for v in model if v.name().startswith('CALLER')):
            raise InfeasibleExploit

        return model_to_calls(model, c.idx_dict), c, model
    except IntractablePath:
        raise InfeasibleExploit


def combined_exploit(p, target_addr, shellcode_addr, target_amount, amount_check='+', initial_storage=dict(),
                     initial_balance=None,
                     max_calls=3, controlled_addrs=set(), flags=None):

    flags = flags or set(opcodes.CRITICAL)

    ctx = ExploitContext(target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                         controlled_addrs)

    sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')}

    critical_paths = []

    for op in opcodes.CRITICAL:
        if op not in flags:
            continue
        ins = p.cfg.filter_ins(op)
        if not ins:
            logging.info('No %s instructions', op)
            continue
        logging.info('Found %d %s instructions', len(ins), op)
        for i, i_path, i_r in p.get_constraints(ins, opcodes.CRITICAL_ARGS[op]):
            logging.info("%s: %s", op, i)
            logging.info("Path: %s", '->'.join('%x' % p for p in i_path))
            if set(i_path) & sload_bbs:
                # if there is a SLOAD on this path,
                # it might benefit from prepending a state-changing path later
                critical_paths.append(i_r)
            try:
                return attempt_exploit([i_r], ctx)
            except InfeasibleExploit:
                continue

    if not critical_paths:
        logging.warning("No state-dependent critical path found, aborting")
        return

    end_ins = p.cfg.filter_ins('RETURN') + p.cfg.filter_ins('STOP')
    if not end_ins:
        logging.info('No RETURN or STOP instructions')
        return
    logging.info('Found %d RETURN and STOP instructions', len(end_ins))
    compatible = defaultdict(lambda: [[]])  # list of lists
    state_changing_paths = []
    for i, (end, end_path, state_changing_r) in enumerate(p.get_constraints(end_ins, find_sstore=True)):
        logging.info("End: %s", end)
        logging.info("Path: %s", '->'.join('%x' % p for p in end_path))
        state_changing_paths.append(state_changing_r)
        for j, critical_r in enumerate(critical_paths):
            if not critical_r.may_read_from(state_changing_r):
                continue
            compatible[j][0].append(i)
            try:
                return attempt_exploit([state_changing_r, critical_r], ctx)
            except InfeasibleExploit:
                continue

    logging.info('All ends: %s', state_changing_paths)

    storage_compatible = defaultdict(list)
    for (i, a_r), (j, b_r) in itertools.product(enumerate(state_changing_paths), enumerate(state_changing_paths)):
        if a_r.may_read_from(b_r):
            storage_compatible[i].append(j)

    calls = [state_changing_paths]
    while len(calls) < max_calls - 1:
        new_ends = [r.copy() for r in state_changing_paths]
        calls.append(new_ends)
        for k, v in compatible.items():
            new_compat = set()
            for c in v[-1]:
                new_compat.update(storage_compatible[c])
            v.append(sorted(new_compat))
        for i, critical_r in enumerate(critical_paths):
            for combo_ids in itertools.product(*compatible[i]):
                combo = [critical_r] + [c[j] for c, j in zip(calls, combo_ids)]
                try:
                    return attempt_exploit(combo[::-1], ctx)
                except InfeasibleExploit:
                    continue

    logging.info('Could not exploit any RETURN+CALL')
